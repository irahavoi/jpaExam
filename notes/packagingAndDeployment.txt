Packaging and Deployment (p. 435)
----------------------------------------------------
persistence.xml - primary coonfig file - defines persistence units.

Since there is one EntityManagerFactory for each persistence unit, you
can think of the configuration of the persistence unit as the configuration of the factory for that
persistence unit

While some providers might still require an additional providerspecific
configuration file, most will also support their properties being specified within the properties
section (described in the “Adding Vendor Properties” section) of the persistence.xml file.
The persistence.xml file is the first step to configuring a persistence unit. All the information
required for the persistence unit should be specified in the persistence.xml file. Once a packaging
strategy has been chosen, the persistence.xml file should be placed in the META-INF directory of the
chosen archive.
Each persistence unit is defined by a persistence-unit element in the persistence.xml file. All the
information for that persistence unit is enclosed within that element. The following sections describe the
metadata that a persistence unit may define when deploying to a Java EE server.

Persistence Unit Name (436)
Every persistence unit must have a name that uniquely identifies it within the scope of its packaging.

if a persistence unit is defined
within a Java EE module, there must not be any other persistence unit of the same name in that module.
For example, if a persistence unit named “EmployeeService” is defined in an EJB JAR named
emp_ejb.jar, there should not be any other persistence units named “EmployeeService” in emp_ejb.jar.

<persistence-unit name="EmployeeService"/>

It may be all that is
needed if the server defaults the remaining information, but not all servers will do this. Some may
require other persistence unit metadata to be present, such as the data source to be accessed.

Transaction Type (436)
Normally, when running in a managed server environment, the
JTA transaction mechanism is used. It is the default transaction type that a server will assume when
none is specified for a persistence unit and is generally the only one that most applications will ever
need, so in practice the transaction type will not need to be specified very often.

When you want to use resource-local transactions
instead of JTA, the transaction-type attribute of the persistence-unit element is used to explicitly
declare the transaction type of RESOURCE_LOCAL or JTA, as in the following example:

<persistence-unit name="EmployeeService" transaction-type="RESOURCE_LOCAL"/>


Persistence Provider:
The Java Persistence API has a pluggable Service Provider Interface (SPI) that allows any compliant Java
EE server to communicate with any compliant persistence provider implementation. Servers normally
have a default provider, though, that is native to the server, meaning that it is implemented by the same
vendor or is shipped with the server. In most cases, this default provider will be used by the server, and
no special metadata will be necessary to explicitly specify it.

In order to switch to a different provider, the provider-supplied class that implements the
javax.persistence.spi.PersistenceProvider interface must be listed in the provider element.

The only
requirement is that the provider JARs be on the server or application classpath and accessible to the
running application at deployment time.

Eclipse Link Provicer configuration:

<persistence-unit name="EmployeeService">
  <provider>org.eclipse.persistence.jpa.PersistenceProvider</provider>
</persistence-unit>

Data Source (437):
A fundamental part of the persistence unit metadata is the description of where the provider should
obtain database connections from in order to read and write entity data. The target database is specified
in terms of the name of a JDBC data source that is in the server JNDI space. This data source must be
globally accessible since the provider accesses it when the persistence application is deployed.
The typical case is that JTA transactions are used, so it is in the jta-data-source element that the
name of the JTA data source should be specified. Similarly, if the transaction type of the persistence unit
is resource-local, the non-jta-data-source element should be used.

<persistence-unit name="EmployeeService">
  <jta-data-source>java:app/jdbc/EmployeeDS</jta-data-source>
</persistence-unit>

in Java EE 6 three new namespaces were introduced to allow names to refer to
global, application or module scope. By using the corresponding standard namespace prefixes of java:global,
java:app, or java:module, a resource can be made available to other components in a wider scope than just
the component, and the name would be portable across container implementations.

<persistence-unit name="EmployeeService">
 <jta-data-source>java:app/jdbc/EmployeeDS</jta-data-source> 
  <non-jta-data-source>java:app/jdbc/NonTxEmployeeDS</non-jta-data-source>
</persistence-unit>

-------------------------------------------------------------------------------------------------
Mapping Files

If a mapping file named “orm.xml” exists in a META-INF directory on the classpath, for example beside
the persistence.xml file, it does not need to be explicitly listed. The provider will automatically search
for such a file and use it if one exists. Mapping files that are named differently or are in a different
location must be listed in the mapping-file elements in the persistence.xml file.


<persistence-unit name="EmployeeService">
  <jta-data-source>java:app/jdbc/EmployeeDS</jta-data-source>
  <mapping-file>META-INF/employee_service_queries.xml</mapping-file>
  <mapping-file>META-INF/employee_service_entities.xml</mapping-file>
</persistence-unit>


----------------------------------------------------------------------------------------------------

Managed Classes (439):
Managed classes are all the classes that must be processed and considered in a persistence unit,
including entities, mapped superclasses, and embeddable classes.

The set of entities, mapped superclasses, and embedded objects that will be managed in a particular
persistence unit is determined by the provider when it processes the persistence unit. At deployment
time it may obtain managed classes from any of four sources. A managed class will be included if it is
among the following:

* Local classes: the annotated classes in the deployment unit in which its
persistence.xml file was packaged.
* Classes in mapping files: the classes that have mapping entries in an XML
mapping file.
* Explicitly listed classes: the classes that are listed as class elements in the
persistence.xml file.
* Additional JARs of managed classes: the annotated classes in a named JAR listed
in a jar-file element in the persistence.xml file

Local classes - When a JAR
is deployed with a persistence.xml file in the META-INF directory, that JAR will be searched for all the
classes that are annotated with @Entity, @MappedSuperclass or @Embeddable.

This method is clearly the simplest way to cause a class to be included because all that has to be
done is to put the annotated classes into a JAR and add the persistence.xml file in the META-INF directory
of the JAR. The provider will take care of going through the classes and finding the entities.

Classes in Mapping Files 

Any class that has an entry in a mapping file will also be considered a managed class in the persistence
unit. It need only be named in an entity, mapped-superclass, or embeddable element in one of the
mapping files. The set of all the classes from all the listed mapping files (including the implicitly
processed orm.xml file) will be added to the set of managed classes in the persistence unit.

Nothing
special has to be done apart from ensuring that the classes named in a mapping file are on the classpath
of the unit being deployed. If they are in the deployed component archive, they will likely already be on
the classpath. But if they aren’t, they must be explicitly included in the classpath.

Explicitly Listed Classes

When the persistence unit is small or when there is not a large number of entities, you may want to list
classes explicitly in class elements in the persistence.xml file. This will cause the listed classes to be
added to the persistence unit.


Since a class that is local to the deployment unit will already be included, we don’t need to list it in a
class element. Explicitly listing the classes is really useful in three main cases.
The first is when there are additional classes that are not local to the deployment unit JAR. For
example, there is an embedded object class in a different JAR that you want to use in an entity in your
persistence unit. You would list the fully qualified class in the class element in the persistence.xml file.
You will also need to ensure that the JAR or directory that contains the class is on the classpath of the
deployed component, for example, by adding it to the manifest classpath of the deployment JAR.
In the second case, we want to exclude one or more classes that may be annotated as an entity. Even
though the class may be annotated with @Entity, we don’t want it to be treated as an entity in this
particular deployed context. For example, it may be used as a transfer object and need to be part of the
deployment unit. In this case, we need to make use of a special element called exclude-unlistedclasses
in the persistence.xml file, which disables local classes from being added to the persistence
unit. When exclude-unlisted-classes is used, none of the classes in the local classes category described
earlier will be included.

The third case is when we expect to be running the application in a Java SE environment and when
we list the classes explicitly because that is the only portable way to do so in Java SE.

Additional JARs of managed classes (p. 441)

The last way to get managed classes included in the persistence unit is to add them to another JAR and
specify the name of the JAR in a jar-file element in the persistence.xml.

The jar-file element is used
to indicate to the provider a JAR that may contain annotated classes. The provider will then treat the
named JAR as if it were a deployment JAR, and it will look for any annotated classes and add them to the
persistence unit. It will even search for an orm.xml file in the META-INF directory in the JAR and process it
just as if it were an additionally listed mapping file.

When listing a JAR in a jar-file element, it must be listed relative to the parent of the JAR file in
which the META-INF/persistence.xml file is located.

emp.ear
  emp-ejb.jar
    META-INF/persistence.xml
  lib/emp-classes.jar
    examples/model/Employee.class

<persistence-unit name="EmployeeService">
  <jta-data-source>java:app/jdbc/EmployeeDS</jta-data-source>
  <jar-file>lib/emp-classes.jar</jar-file>
</persistence-unit>



Shared Cache Mode
----------------------------------------------------------
The shared-cache-mode element is optional, but when specified it may be set to one of the five
options:

UNSPECIFIED The provider chooses whatever option is most appropriate for that provider.
ALL Cache all the entities in the persistence unit.
NONE Do not cache any of the entities in the persistence unit.
DISABLE_SELECTED Cache all entities except those annotated with @Cacheable(false).
ENABLE_SELECTED Cache no entities except those annotated with @Cacheable(true).

Validation Mode
The validation-mode element in the persistence.xml file determines whether validation is enabled or not.

It may be set to AUTO, meaning that in the
container environment validation is enabled, but when not running in the container, validation will be
enabled only if there is a validation provider available. Setting it to CALLBACK will enable validation and
assume that a validation provider is on the classpath.

The default is AUTO, which enables validation, so if you do not intend to use validation we
recommend that you explicitly disable it by setting the validation-mode element to NONE. This will bypass
the validation provider checks and prevent you from incurring any validation overhead if at some point
later on a provider happens to show up on the classpath.

Adding Vendor Properties
The properties element gives a deployer the chance to supply standard and 
provider-specific settings for the persistence unit. To
guarantee runtime compatibility, a provider must ignore properties it does not understand

<persistence-unit name="EmployeeService">
  ...
  <properties>
    <property name="eclipselink.logging.level" value="FINE"/>
    <property name="eclipselink.cache.size.default" value="500"/>
  </properties>
</persistence-unit>



------------------------------------------------------------------------------------------------
Building and Deploying (443)

application.xml:

<application ... >
  ...
  <library-directory>myDir/jars</library-directory>
</application>

When you are deploying a WAR and want to put an additional JAR of entities on the classpath, you
can put the JAR in the WEB-INF/lib directory of the WAR. This causes the JAR to be on the classpath, and
the classes in it are accessible to all the classes in the WAR.

-----------------------------------------------------------------------------------------------
Packaging options: EJB Modules, web modules, and persistence archives.

EJB Jar:




