Advanced Object-Relational Mapping (301)
----------------------------------------------------------
Table and Column Names:

@Table(name="employee")
@Table(name="Employee")
@Table(name="EMPLOYEE")

Some database names are intended to be case-specific, and must be explicitly delimited.
While it is by no means common, or good practice, a database in theory could have an EMPLOYEE table as well as an Employee table.

The method of
delimiting is the use of a second set of double quotes, which must be escaped, around the identifier. The
escaping mechanism is the backslash (the “\” character), which would cause the following annotations
to refer to different tables:
@Table(name="\"Employee\"")
@Table(name="\"EMPLOYEE\"")

When in XML file:
<column name="&quot;ID&quot;"/>
<column name="&quot;Id&quot;"/>

By including the empty delimited-identifiers element in the XML mapping file, all identifiers in
the persistence unit will be treated as delimited, and quotes will be added to them when they are passed
to the driver.
-----------------------------------------------------------
Complex Embedded Objects (303):
Embedded objects may have embedded objects and relations themselves:

@Embeddable @Access(AccessType.FIELD)
public class ContactInfo {
  @Embedded
  private Address residence;
  @ManyToOne
  @JoinColumn(name="PRI_NUM")
  private Phone primaryPhone;
  @ManyToMany 
  @MapKey(name="type")
  @JoinTable(name="EMP_PHONES")
  private Map<String, Phone> phones;
  // ...
}

@Entity
public class Phone {
  @Id String num;
  @ManyToMany(mappedBy="contactInfo.phones")
  List<Employee> employees;
  String type;
  // ...
}

if an embedded object is a part of an element collection
then the embedded object in the collection can only include mappings where the foreign key is stored in
the source table. It can contain owned relationships, such as one-to-one and many-to-one, but it cannot
contain one-to-many or many-to-many relationships where the foreign key is in either the target table
or a join table. Similarly, collection table-based mappings like element collections are unsupported.

(p. 305)
Overriding relationships within embeddables.
@AssociationOverride provides ability to override relationship columns and join tables.

@Entity
public class Customer {
  @Id int id;
  @Embedded
  @AttributeOverride(name="address.zip", column=@Column(name="ZIP"))
  @AssociationOverrides({
   @AssociationOverride(name="primaryPhone",
     joinColumns=@JoinColumn(name="EMERG_PHONE")),
   @AssociationOverride(name="phones",
     joinTable=@JoinTable(name="CUST_PHONE"))})
  private ContactInfo contactInfo;
  // ...
}
---------------------------------------------------------------------------------------------------------
Compound primary Keys (306)
If the key consists of several attributes, you have to create a separate class for the key - primary key class.

Primary key classes must include method definitions for equals() and hashCode() in order to be able
to be stored and keyed on by the persistence provider, and their fields or properties must be in the set of
valid identifier types. They also must be public, implement Serializable and have a no-arg constructor.

There are 2 approaches for creating compound keys:
  1. Id class. Each field of the entity that makes up the primary key is marked with @Id annotation.
     The primary key class is defined separately and associated with the entity using @IdClass annotation:

@Entity
@IdClass(EmployeeId.class)
public class Employee {
  @Id private String country;
  @Id
  @Column(name="EMP_ID")
  private int id;
  private String name;
  private Long Salary;
}
 
public class EmployeeId implements Serializable {
  private String country;
  private int id;
  public EmployeeId() {}
  public EmployeeId(String country, int id) {
    this.country = country;
    this.id = id;
  }
  public String getCountry() { return country; }
  public int getId() { return id; }
  public boolean equals(Object o) {
    return ((o instanceof EmployeeId) &&
    country.equals(((EmployeeId)o).getCountry()) &&
    id == ((EmployeeId)o).getId());
  } 
  public int hashCode() {
   return country.hashCode() + id;
  }
}  

Note that there are no setter methods on the EmployeeId class. Once it has been constructed using
the primary key values, it can’t be changed. We do this to enforce the notion that a primary key value
cannot be changed, even when it is made up of multiple fields.

The id class is useful as a structured object that encapsulates all of the primary key information. For
example, when doing a query based upon the primary key:

EmployeeId id = new EmployeeId(country, id);
Employee emp = em.find(Employee.class, id);

  2. Embedded Id class:
 The embedded id class is just an embedded object that happens to be composed of the primary
key components. We use an @EmbeddedId annotation to indicate that it is not just a regular embedded
object but also a primary key class. When we use this approach, there are no @Id annotations on the
class, nor is the @IdClass annotation used. You can think of @EmbeddedId as the logical equivalent to
putting both @Id and @Embedded on the field.

@Embeddable
public class EmployeeId {
  private String country;
  @Column(name="EMP_ID")
  private int id;
  public EmployeeId() {}
  public EmployeeId(String country, int id) { 
    this.country = country;
    this.id = id;
  }
  // ...
}

  
Using the embedded primary key class is no different than using a regular embedded type, except
that the annotation used on the attribute is @EmbeddedId instead of @Embedded.
@Entity
public class Employee {
  @EmbeddedId private EmployeeId id;
  private String name;
  //...
}

----------------------------------------------------------------------------------------------------------------
Derived Identifiers:
When an identifier in one entity includes a foreign key to another entity, we call it a derived identifier.

Because the entity containing the derived identifier depends upon another entity for its identity, we call
the first the dependent entity. The entity that it depends upon is the target of a many-to-one or one-toone
relationship from the dependent entity, and is called the parent entity.

Example: Department has an ID as PK
	 Project has it's own ID as PK and Department.ID as PK and FK.



The dependent object cannot exist without a primary key, and since that primary key consists of the
foreign key to the parent entity it should be clear that a new dependent entity cannot be persisted
without the relationship to the parent entity being established.


Basic Rules for Derived Identifiers (310):
A dependent entity might have multiple parent entities, i.e., a derived identifier
might include multiple foreign keys.

A dependent entity must have all its relationships to parent entities set before it
can be persisted.

If an entity class has multiple id attributes, then not only must it use an id class,
but there must also be a corresponding attribute of the same name in the id class
as each of the id attributes in the entity

Id attributes in an entity might be of a simple type, or of an entity type that is the
target of a many-to-one or one-to-one relationship

If an id attribute in an entity is of a simple type, then the type of the matching
attribute in the id class must be of the same simple type

---------------------------------------------------------------------------------------------------------------
Advanced mapping elements:
Read-only mappings (316)
JPA API allows to mark certain fields as read-only using "insertable" and "updatable" elements of the 
@Column and @JoinColumn annotations. By default these elements are true.

@Column(insertable=false, updatable=false)

---------------------------------------------------------------------------------------------------------------
Optionality:
There are settings on some of the logical mappings that allow a basic
mapping or a single-valued association mapping to be left empty or required to be specified in the
object model. The element that requires or permits such behavior is the optional element in the @Basic,
@ManyToOne, and @OneToOne annotations.

When the optional element is specified as false, it indicates to the provider that the field or property
mapping may not be null. The API does not actually define what the behavior is in the case when the
value is null, but the provider may choose to throw an exception or simply do something else.

The optional element may also be used by the
provider when doing schema generation, because, if optional is set to true, then the column in the
database must also be nullable.

@ManyToOne(optional=false) <-- makes the related object Required.

----------------------------------------------------------------------------------------------------------------
Advanced Relationships (317)
Mapping legacy databases can be tricky.
Using Join tables:
@JoinTable is used for overriding join table names.

@Entity
public class Employee {
  @Id private int id;
  private String name;
  private long salary;
  @ManyToOne
  @JoinTable(name="EMP_DEPT")
  private Department department;
// ...
}

Avoiding Join Tables:
it is possible to map unidirectional relations without a join table. 

It requires the foreign key to be in the target table, or “many” side of the relationship, even though the target object
does not have any reference to the “one” side.

We call this a unidirectional one-to-many target foreign
key mapping, because the foreign key is in the target table instead of a join table.

To use this mapping, we first indicate that the one-to-many relationship is unidirectional by not
specifying any mappedBy element in the annotation. Then we specify a @JoinColumn annotation on the
one-to-many attribute to indicate the foreign key column. The catch is that the join column that we are
specifying applies to the table of the target object, not the source object in which the annotation
appears.


@Entity
public class Department {
 @Id private int id;
 @OneToMany
 @JoinColumn(name="DEPT_ID")
 private Collection<Employee> employees;
// ...
}

Negative implications:
From a performance standpoint, think of the case when both the state of an Employee is changed,
and the Department that it belongs to is changed. When writing out the Employee state the foreign key to
the Department is not known because the Employee entity does not have any reference to it. In this case,
the Employee might have to be written out twice, once for the changed state of the Employee, and a
second time when the Department entity changes are written out and the foreign key from Employee to
Department must be updated to point to the Department that is referring to it.
------------------------------------------------------------------------------------------------------------------------------------
Compound Join Columns (320)

For multiple join columns use @JoinColumns

Example: employees have managers and that each manager has a number of employees that
work for him. You may not find that very interesting until you realize that managers are themselves
employees, so the join columns are actually self-referential, that is, referring to the same table they are
stored in.

@Entity
@IdClass(EmployeeId.class)
public class Employee {
 @Id private String country;
 @Id
 @Column(name="EMP_ID")
 private int id;
 @ManyToOne
 @JoinColumns({
  @JoinColumn(name="MGR_COUNTRY", referencedColumnName="COUNTRY"),
  @JoinColumn(name="MGR_ID", referencedColumnName="EMP_ID")})
 private Employee manager;
 @OneToMany(mappedBy="manager")
 private Collection<Employee> directs;
 // ...
}

Example of compound join columns for many-to-many:
@ManyToMany
@JoinTable(
 name="EMP_PROJECT",
 joinColumns={
  @JoinColumn(name="EMP_COUNTRY", referencedColumnName="COUNTRY"),
  @JoinColumn(name="EMP_ID", referencedColumnName="EMP_ID")},
  inverseJoinColumns=@JoinColumn(name="PROJECT_ID"))
private Collection<Project> projects;
-----------------------------------------------------------------------------------------------------------------------------------------
Orphan removal (322)



