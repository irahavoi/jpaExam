Advanced Topics (343):
SQL queries:
jpa supports native queries in plain sql.
despite the enhancements made in JPA 2.0, still contains only a subset of the features
supported by many database vendors. Inline views (subqueries in the FROM clause), hierarchical
queries, access to stored procedures, and additional function expressions to manipulate date and time
values are just some of the features not supported in JP QL.

there are cases where the only way to achieve the performance required by an application is to replace the JP QL
query with a hand-optimized SQL version.

We recommend avoiding SQL initially if possible and then
introducing it only when necessary.

private static final String ORG_QUERY =
"SELECT emp_id, name, salary " +
"FROM emp " +
"START WITH manager_id = ? " +
"CONNECT BY PRIOR emp_id = manager_id";

try {
  conn = hrDs.getConnection();
  sth = conn.prepareStatement(ORG_QUERY);
  sth.setLong(1, managerId);
  ResultSet rs = sth.executeQuery();
  ArrayList<Employee> result = new ArrayList<Employee>();
  while (rs.next()) {
   Employee emp = new Employee();
   emp.setId(rs.getInt(1));
   emp.setName(rs.getString(2));
   emp.setSalary(rs.getLong(3));
   result.add(emp);
}
  return result;
} catch (SQLException e) {
  throw new EJBException(e);
}



Defining and executing sql queries:
SQL queries may be defined dynamically at runtime or named in persistence unit metadata, similar to
the JP QL query definitions discussed in Chapter 7. The key difference between defining JP QL and SQL
queries lies in the understanding that the query engine should not parse and interpret vendor-specific
SQL. In order to execute a SQL query and get entity instances in return, additional mapping information
about the query result is required.

The first and simplest form of dynamically defining a SQL query that returns an entity result is to
use the createNativeQuery() method of the EntityManager interface, passing in the query string and the
entity type that will be returned.

em.createNativeQuery(sql, Employee.class);

If the column aliases of the query do not match up exactly with the object-relational mappings for
the entity, or if the results contain both entity and non-entity results, SQL result set mapping metadata is
required. SQL result set mappings are defined as persistence unit metadata and are referenced by name.

When the createNativeQuery() method is invoked with a SQL query string and a result set mapping
name, the query engine uses this mapping to build the result set.

Named SQL queries are defined using the @NamedNativeQuery annotation.


Like JP QL named queries, the name of the query must be unique within the persistence unit.

If the result type is an entity,
the resultClass element may be used to indicate the entity class. If the result requires a SQL mapping,
the resultSetMapping element may be used to specify the mapping name.

@NamedNativeQuery(
  name="orgStructureReportingTo",
  query="SELECT emp_id, name, salary, manager_id, dept_id, address_id " +
        "FROM emp " +
	"START WITH manager_id = ? " +
	"CONNECT BY PRIOR emp_id = manager_id",
resultClass=Employee.class
)


One advantage of using named SQL queries is that the application can use the createNamedQuery()
method on the EntityManager interface to create and execute the query. The fact that the named query
was defined using SQL instead of JP QL is not important to the caller.

A further benefit is that createNamedQuery() can return a TypedQuery whereas the createNativeQuery() method returns an
untyped Query.

One thing to be careful of with SQL queries that return entities is that the resulting entity instances
become managed by the persistence context, just like the results of a JP QL query. If you modify one of
the returned entities, it will be written to the database when the persistence context becomes associated
with a transaction.

This is normally what you want, but it requires that any time you select data that
corresponds to existing entity instances, it is important to ensure that all the necessary data required to
fully construct the entity is part of the query. If you leave out a field from the query, or default it to some
value and then modify the resulting entity, there is a possibility that you will overwrite the correct
version already stored in the database. This is because the missing state will be null (or some default
value according to the type) in the entity. When the transaction commits, the persistence context does
not know that the state was not properly read in from the query and might just attempt to write out null
or the default value.


SQL data-manipulation statements (INSERT, UPDATE, and DELETE) are also supported as a
convenience so that JDBC calls do not have to be introduced in an application otherwise limited to JPA.
To define such a query, use the createNativeQuery() method, but without any mapping information.

em.createNativeQuery(INSERT_SQL)
.setParameter(1, message)
.executeUpdate();

em.createNativeQuery(DELETE_SQL)
.executeUpdate();

SQL Result Set Mapping (348)
A SQL result set mapping is defined using the @SqlResultSetMapping annotation. It may be placed
on an entity class and consists of a name (unique within the persistence unit) and one or more entity
and column mappings.

@SqlResultSetMapping(
  name="employeeResult",
  entities=@EntityResult(entityClass=Employee.class)
)

Here we have defined a SQL result set mapping called employeeResult that may be referenced by
any query returning Employee entity instances. The mapping consists of a single entity result, specified
by the @EntityResult annotation, which references the Employee entity class. THe query must supply 
values for all columns mapped by the entity, including foreign keys. It is vendor-specific whether the
entity is partially constructed or whether an error occurs if any required entity state is missing.


Mapping Foreign Keys(349)
Multiple Result Mappings:
a query may return more than one entity at a time;
This is most often useful if there is a one-to-one relationship between two entities;

For example:
SELECT emp_id, name, salary, manager_id, dept_id, address_id, id, street, city, state, zip
FROM emp, address
WHERE address_id = id

Mapping for this query:
@SqlResultSetMapping(
  name="EmployeeWithAddress",
  entities={@EntityResult(entityClass=Employee.class),
	    @EntityResult(entityClass=Address.class)}
)

Mapping Column Aliases
If the column aliases in the SQL statement do not directly match up with the names specified in the
column mappings for the entity, field result mappings are required for the query engine to make the
correct association.

Suppose, for example, that both the EMP and ADDRESS tables listed in the previous example 
used the column ID for their primary key. The query would have to be altered to alias the ID
columns so that they are unique:

SELECT emp.id AS emp_id, name, salary, manager_id, dept_id, address_id,
address.id, street, city, state, zip
FROM emp, address
WHERE address_id = address.id

The @FieldResult annotation is used to map column aliases to the entity attributes in situations
where the name in the query is not the same as the one used in the column mapping.
More than one
@FieldResult may be specified, but only the mappings that are different need to be specified.


@SqlResultSetMapping(
  name="EmployeeWithAddress",
  entities={@EntityResult(entityClass=Employee.class,
  fields=@FieldResult(
    name="id",
    column="EMP_ID")),
  @EntityResult(entityClass=Address.class)}
)

---------------------------------------------------------------------------------------------------------
Mapping Scalar Result Columns (350):

Mapping compound keys:
@EntityResult(
 entityClass=Employee.class,
 fields={
  @FieldResult(name="country", column="MGR_COUNTRY"),
  @FieldResult(name="id", column="MGR_ID"),
  @FieldResult(name="name", column="MGR_NAME"),
  @FieldResult(name="salary", column="MGR_SALARY"),
  @FieldResult(name="manager.country",
   column="MGR_MGR_COUNTRY"),
  @FieldResult(name="manager.id", column="MGR_MGR_ID")
}


Mappping Inheritance:

The key thing to remember is that if the results include
more than one entity type, each of the columns for all the possible entity types must be represented in
the query.

The only special
element in the @EntityResult annotation for use with inheritance is the discriminatorColumn element.
This element allows the name of the discriminator column to be specified in the unlikely event that it is
different from the mapped version.

To understand aliasing a discriminator column, consider the following query that returns data from
another EMPLOYEE_STAGE table structured to use single-table inheritance:
SELECT id, name, start_date, daily_rate, term, vacation, hourly_rate, salary, pension, type
FROM employee_stage

@SqlResultSetMapping(
	name="EmployeeStageMapping",
	entities=
		@EntityResult(
		 entityClass=Employee.class,
		 discriminatorColumn="TYPE",
		 fields={
		  @FieldResult(name="startDate", column="START_DATE"),
		  @FieldResult(name="dailyRate", column="DAILY_RATE"),
		  @FieldResult(name="hourlyRate", column="HOURLY_RATE")

---------------------------------------------------------------------------------------------------
Parameter Binding : JPA guarantees only the use of positional parameter binding for sql queries.

--------------------------------------------------------------------------------------------------


Lifecycle callbacks:In order to respond to any one or more of the events, an entity
class or any of its superclasses may declare one or more methods that will be invoked by the provider
when the event gets fired. These methods are called callback methods.


Lifecycle Events. Four categories: persisting, updating, removing, and loading.

These are really data-level events that correspond to the database operations of inserting,
updating, deleting, and reading; and except for loading, each has a Pre event and a Post event. In the
load category there is only a PostLoad event because it would not make any sense for there to be PreLoad
that was not yet built.

Thus the full suite of lifecycle events that can occur is composed of
PrePersist, PostPersist, PreUpdate, PostUpdate, PreRemove, PostRemove, and PostLoad.


"PrePersist and PostPersist"
The PrePersist event notifies an entity when EntityManager.persist() has been successfully invoked on
it. PrePersist events may also occur on a merge() call when a new entity has been merged into the
persistence context.

If multiple entities are cascaded to during the same operation, the order in which the PrePersist
callbacks occur cannot be relied upon.

PostPersist events occur when an entity is inserted, which normally occurs during the transaction
completion phase. Firing of a PostPersist event does not indicate that the entity has committed
successfully to the database because the transaction in which it was persisted may be rolled back after
the PostPersist event but before the transaction successfully commits.

"PreRemove and PostRemove"
When an EntityManager.remove() call is invoked on an entity, the PreRemove callback is triggered. This
callback implies that an entity is being queued for deletion, and any related entities across relationships
that have been configured with the REMOVE cascade option will also get a PreRemove notification. When
the SQL for deletion of an entity finally does get sent to the database, the PostRemove event will get fired.
As with the PostPersist lifecycle event, the PostRemove event does not guarantee success. The enclosing
transaction may still be rolled back.

"PreUpdate and PostUpdate"
Updates to managed entities may occur at any time, either within a transaction or (in the case of an
extended persistence context) outside a transaction. Because there is no explicit method on the
EntityManager, the PreUpdate callback is guaranteed to be invoked only at some point before the
database update. Some implementations may track changes dynamically and may invoke the callback
on each change, while others may wait until the end of the transaction and just invoke the callback once.

The PostUpdate callback occurs right after the
database update. The same potential for rollback exists after PostUpdate callbacks as with PostPersist
and PostRemove.

"PostLoad"
The PostLoad callback occurs after the data for an entity is read from the database and the entity
instance is constructed. This can get triggered by any operation that causes an entity to be loaded,
normally by either a query or traversal of a lazy relationship. It can also happen as a result of a refresh()
call on the entity manager. When a relationship is set to cascade REFRESH, the entities that get cascaded
to will also get loaded. The invocation of entities in a single operation, be it a query or a refresh, is not
guaranteed to be in any order

Tip: Other lifecycle methods may be defined by specific providers, such as when an entity is merged or
copied/cloned.


"Callback Methods" (355)
Callback methods may be defined a few different ways, the most basic of which is to simply define a
method on the entity class. Designating the method as a callback method involves two steps:
1. Define a method with according to a given signature and annotate is with the appropriate annotation.
The callback method may have any name, but must have a signature that takes no parameters and has a return type of void. 
Final or static methods are not valid callback methods.

Checked exceptions may not be thrown from callback methods because the method definition of a
callback method is not permitted to include a throws clause. Runtime exceptions may be thrown,
though, and if they are thrown while in a transaction, they will cause the provider to not only abandon
invocation of subsequent lifecycle event methods in that transaction, but also mark the transaction for
rollback.

A method is indicated as being a callback method by being annotated with a lifecycle event
annotation. The relevant annotations match the names of the events listed earlier: @PrePersist,
@PostPersist, @PreUpdate, @PostUpdate, @PreRemove, @PostRemove, and @PostLoad. A method may be
annotated with multiple lifecycle event annotations, but only one lifecycle annotation of a given type
may be present in an entity class.

366

Enterprise contexts (357)

Entity Listeners: 357
Callback methods in the entity are fine when you don’t mind if the event callback logic is included in the
entity, but what if you want to pull the event handling behavior out of the entity class into a different
class?

class? To do this, you can use an entity listener.

it is a class on which
you can define one or more lifecycle callback methods to be invoked for the lifecycle events of an entity.

only one method in each listener class may be
annotated for each event type. Multiple event listeners may be applied to an entity, though.

On an entity listener, a
callback method must have a similar signature as on an entity with the exception that it must also have a
single defined parameter of a type that is compatible with the entity type, as the entity class, a superclass
(including Object), or an interface implemented by the entity. A method with the signature public void
foo(Object o) {} is an example of a valid callback method on an entity listener. The method must then
be annotated with the necessary event annotation(s).

Entity listener classes must be stateless, meaning that they should not declare any fields. A single
instance may be shared among multiple entity instances and may even be invoked upon concurrently
for multiple entity instances. In order for the provider to be able to create instances of the entity listener,
every entity listener class must have a public no-argument constructor.

 Attaching Entity Listeners to Entities:

An entity designates the entity listeners that should be notified of its lifecycle events through the use of
the @EntityListeners annotation. One or more entity listeners may be listed in the annotation.

When a
lifecycle event occurs, the provider will iterate through each of the entity listeners in the order in which
they were listed and instantiate an instance of the entity listener class that has a method annotated with
the annotation for the given event. It will invoke the callback method on the listener, passing in the
entity to which the event applies. After it has done this for all the listed entity listeners, it will invoke the
callback method on the entity if there is one.

If any of the listeners throws an exception, it will abort the
callback process, causing the remaining listeners and the callback method on the entity to not be
invoked.

Entity
@EntityListeners({EmployeeDebugListener.class, NameValidator.class})
public class Employee{ .. }

public class EmployeeDebugListener {
@PrePersist
public void prePersist(Employee emp) {
System.out.println("Persist on employee id: " + emp.getId());
}

In general, when a
callback method accesses state beyond what should be publicly accessible, it is best suited to being in
the entity and not in an entity listener.


"Default Entity Listeners"
   A listener may be attached to more than one type of entity simply by being listed in the
@EntityListeners annotation of more than one entity. This can be useful in cases where the listener
provides a more general facility or wide-ranging runtime logic.

For even broader usage of an entity listener across all the entities in a persistence unit, one or more
default entity listeners may be declared. There is currently no standard annotation target for persistence
unit scoped metadata, so this kind of metadata can be declared only in an XML mapping file.

When a list of default entity listeners is declared, it will be traversed in the order they were listed in
the declaration, and each one that has a method annotated or declared for the current event will be
invoked upon.
Default entity listeners will always get invoked before any of the entity listeners listed in
the @EntityListeners annotation for a given entity.

Any entity may opt out of having the default entity listeners applied to it by using the
@ExcludeDefaultListeners annotation. When an entity is annotated with this annotation, none of the
declared default listeners will get invoked for the lifecycle events for instances of that entity type.




