Criteria API (p. 267 of 538)

CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Employee> c = cb.createQuery(Employee.class);
Root<Employee> emp = c.from(Employee.class);
c.select(emp)
.where(cb.equal(emp.get("name"), "John Smith"));

p. 269
----------------------------------------------------------------------------------
Building Criteria API queries (272).
Creating a Query Definition:

EntityManager.getCriteriaBuilder()

3 methods for creating a query definition:

	CriteriaBuilder
		.createQuery(Class<T>)  <--The result is typed
		.createQuery()  <-- The result is object
		.createTupleQuery() <-- Returns Tuple, an object containing an assortment of objects and applies typing to 
					aggregate parts. It can be used whenever multiple items are returned and you want to combine 
					them into a single typed object.

JP QL Clause --> Criteria API --> Interface Method

SELECT -->  CriteriaQuery -->  select()
	    Subquery --> select()
FROM --> AbstractQuery --> from()
WHERE --> AbstractQuery --> where()
ORDER BY --> CriteriaQuery  --> orderBy()
GROUP BY --> AbstractQuery --> groupBy()
HAVING --> AbstractQuery --> having()
		
---------------------------------------------------------------------------------
Criteria Objects and Mutability (p. 274)
The majority of objects created through the criteria API are in fact immutable.

Only the CriteriaBuilder methods that create query definition objects produce truly mutable
results. The CriteriaQuery and Subquery objects are intended to be modified many times by invoking
methods such as select(), from(), and where(). But even here care must be taken as invoking methods
twice can have one of two different effects. In most cases, invoking a method twice replaces the contents
within the object with the argument being supplied. For example, invoking select() twice with two
different arguments results in only the argument from the second invocation actually remaining as part
of the query definition.
In some cases, however, invoking a method twice is in fact addition. Invoking from() twice with
different arguments results in multiple query roots being added to the query definition.
----------------------------------------------------------------------------------
Query Roots and Path Expressions (275)

The AbstractQuery interface (parent of CriteriaQuery) provides the from() method to define the
abstract schema type that will form the basis for the query. This method accepts an entity type as a
parameter and adds a new root to the query.

CriteriaQuery<Employee> c = criteriaBuilder.createQuery(Employee.class);
Root<Employee> emp = c.from(Employee.class);

The Root interface
is itself extended from the From interface, which exposes functionality for joins. The From interface
extends Path, which further extends Expression and then Selection, allowing the root to be used in other
parts of the query definition.

Calls to the from() method are additive. Each call adds another root to the query, resulting in a Cartesian
product when more than one root is defined if no further constraints are applied in the WHERE clause.

Example with multiple roots:
SELECT DISTINCT d FROM Department d, Employee e WHERE d = e.department

Using criteria API, this query is constructed by calling from() twice:

CriteriaQuery<Department> c = cb.createQuery(Department.class);

Root<Department> dept = c.from(Department.class);
Root<Employee> emp = c.from(Employee.class);

c.select(dept)
  .distinct(true)
  .where(cb.equal(dept, emp.get("department")));



PATH Expressions:

Consider the following basic JP QL query, which returns all the employees living in New York City:
SELECT e
FROM Employee e <-- Query root
WHERE e.address.city = 'New York' <--Path expression

To represent this path expression using the criteria API, we would use the following expression:
emp.get("address").get("city");

.get() method here is equivalent to the dot operator used in JP QL. It returns a Path object - which
allows this method to be chained together.

CriteriaQuery<Employee> c = cb.createQuery(Employee.class);
Root<Employee> emp = c.from(Employee.class);
c.select(emp)
  .where(cb.equal(emp.get("address").get("city"), "New York"));

Once again it is worth emphasizing that the from() method of
AbstractQuery should never be invoked more than once for each desired root. Invoking it multiple times
will result in additional roots being created and a Cartesian product if not careful. Always store the root
objects locally and refer to them when necessary.


-----------------------------------------------------------------------------------------------------------
The SELECT CLAUSE (p. 277)

Selecting Single Expressions:

criteraQuery.select()

Some vendors may allow the call to select() to be omitted in the case where there is a single query
root and it matches the declared result type for the query. This is non-portable behavior.

criteriaQuery.distinct(true); <-- removes dubplicates


The type of the expression provided to the select() method must be compatible with the result type used to
create the CriteriaQuery object.

For example, if the CriteriaQuery object was created by invoking
createQuery(Project.class) on the CriteriaBuilder interface, then it will be an error to attempt to set
an expression resolving to the Employee entity using the select() method.

------------------------------------------------------------------------------------------------------------
Selecting Multiple Expressions.

When defining a SELECT clause that involves more than one expression, the criteria API approach
required depends on how the query definition was created.

If the result type is Tuple, then a
CompoundSelection<Tuple> object must be passed to select().

If the result type is a non-persistent class
that will be created using a constructor expression, then the argument must be a
CompoundSelection<[T]> object, where [T] is the class type of the non-persistent class.

Finally, if the result type is an array of objects, then a CompoundSelection<Object[]> object must be provided. These
objects are created with the tuple(), construct() and array() methods of the CriteriaBuilder interface,
respectively.

CriteriaQuery<Tuple> c= cb.createTupleQuery();
Root<Employee> emp = c.from(Employee.class);
c.select(cb.tuple(emp.get("id"), emp.get("name")));

.multiselect() <-- method of the CriteriaQuery interface. may be used to set
the SELECT clause. The multiselect() method will create the appropriate argument type given the
result type of the query.

------------------------------------------------------------------------------------------------------------
Using ALiases:
Like JP QL, aliases may be set on expressions in the SELECT clause, which will then be included in the resulting
sql.

Aliases are useful when the query has a result type of Tuple. 

CriteriaQuery<Tuple> c= cb.createTupleQuery();
Root<Employee> emp = c.from(Employee.class);
c.multiselect(emp.get("id").alias("id"), emp.get("name").alias("fullName"));

Invoking alias() changes the original Selection object and returns it from
the method invocation. It is invalid to set the alias of a Selection object more than once.

Making use of the alias when iterating over the query results is as simple as requesting the
expression by name:

TypedQuery<Tuple> q = em.createQuery(c);
for (Tuple t : q.getResultList()) {
  String id = t.get("id", String.class);
  String fullName = t.get("fullName", String.class);
  // ...
}
--------------------------------------------------------------------------------------------------------------
FROM Clause. (expressing joins using Criteria API)

Inner and outer Joins. - p.280
Join expressions are created using the join() method of the From interface, which is extended both by
Root, which we covered earlier, and Join, which is the object type returned by creating join expressions.
This means that any query root may join, and that joins may chain with one another. The join() method
requires a path expression argument and optionally an argument to specify the type of join,
JoinType.INNER or JoinType.LEFT, for inner and outer joins respectively.


Join<Employee,Project> project = emp.join("projects", JoinType.LEFT);

Had the JoinType.LEFT argument been omitted, the join type would have defaulted to be an inner join.

Joins may also be cascaded in a single statement. The resulting join will be typed by the source and
target of the last join in the statement:
Join<Employee,Project> project = dept.join("employees").join("projects");














