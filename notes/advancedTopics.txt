Advanced Topics (343):
SQL queries:
jpa supports native queries in plain sql.
despite the enhancements made in JPA 2.0, still contains only a subset of the features
supported by many database vendors. Inline views (subqueries in the FROM clause), hierarchical
queries, access to stored procedures, and additional function expressions to manipulate date and time
values are just some of the features not supported in JP QL.

there are cases where the only way to achieve the performance required by an application is to replace the JP QL
query with a hand-optimized SQL version.

We recommend avoiding SQL initially if possible and then
introducing it only when necessary.

private static final String ORG_QUERY =
"SELECT emp_id, name, salary " +
"FROM emp " +
"START WITH manager_id = ? " +
"CONNECT BY PRIOR emp_id = manager_id";

try {
  conn = hrDs.getConnection();
  sth = conn.prepareStatement(ORG_QUERY);
  sth.setLong(1, managerId);
  ResultSet rs = sth.executeQuery();
  ArrayList<Employee> result = new ArrayList<Employee>();
  while (rs.next()) {
   Employee emp = new Employee();
   emp.setId(rs.getInt(1));
   emp.setName(rs.getString(2));
   emp.setSalary(rs.getLong(3));
   result.add(emp);
}
  return result;
} catch (SQLException e) {
  throw new EJBException(e);
}



Defining and executing sql queries:
SQL queries may be defined dynamically at runtime or named in persistence unit metadata, similar to
the JP QL query definitions discussed in Chapter 7. The key difference between defining JP QL and SQL
queries lies in the understanding that the query engine should not parse and interpret vendor-specific
SQL. In order to execute a SQL query and get entity instances in return, additional mapping information
about the query result is required.

The first and simplest form of dynamically defining a SQL query that returns an entity result is to
use the createNativeQuery() method of the EntityManager interface, passing in the query string and the
entity type that will be returned.

em.createNativeQuery(sql, Employee.class);

If the column aliases of the query do not match up exactly with the object-relational mappings for
the entity, or if the results contain both entity and non-entity results, SQL result set mapping metadata is
required. SQL result set mappings are defined as persistence unit metadata and are referenced by name.

When the createNativeQuery() method is invoked with a SQL query string and a result set mapping
name, the query engine uses this mapping to build the result set.

Named SQL queries are defined using the @NamedNativeQuery annotation.


Like JP QL named queries, the name of the query must be unique within the persistence unit.

If the result type is an entity,
the resultClass element may be used to indicate the entity class. If the result requires a SQL mapping,
the resultSetMapping element may be used to specify the mapping name.

@NamedNativeQuery(
  name="orgStructureReportingTo",
  query="SELECT emp_id, name, salary, manager_id, dept_id, address_id " +
        "FROM emp " +
	"START WITH manager_id = ? " +
	"CONNECT BY PRIOR emp_id = manager_id",
resultClass=Employee.class
)


One advantage of using named SQL queries is that the application can use the createNamedQuery()
method on the EntityManager interface to create and execute the query. The fact that the named query
was defined using SQL instead of JP QL is not important to the caller.

A further benefit is that createNamedQuery() can return a TypedQuery whereas the createNativeQuery() method returns an
untyped Query.

One thing to be careful of with SQL queries that return entities is that the resulting entity instances
become managed by the persistence context, just like the results of a JP QL query. If you modify one of
the returned entities, it will be written to the database when the persistence context becomes associated
with a transaction.

This is normally what you want, but it requires that any time you select data that
corresponds to existing entity instances, it is important to ensure that all the necessary data required to
fully construct the entity is part of the query. If you leave out a field from the query, or default it to some
value and then modify the resulting entity, there is a possibility that you will overwrite the correct
version already stored in the database. This is because the missing state will be null (or some default
value according to the type) in the entity. When the transaction commits, the persistence context does
not know that the state was not properly read in from the query and might just attempt to write out null
or the default value.


SQL data-manipulation statements (INSERT, UPDATE, and DELETE) are also supported as a
convenience so that JDBC calls do not have to be introduced in an application otherwise limited to JPA.
To define such a query, use the createNativeQuery() method, but without any mapping information.

em.createNativeQuery(INSERT_SQL)
.setParameter(1, message)
.executeUpdate();

em.createNativeQuery(DELETE_SQL)
.executeUpdate();

SQL Result Set Mapping (348)
A SQL result set mapping is defined using the @SqlResultSetMapping annotation. It may be placed
on an entity class and consists of a name (unique within the persistence unit) and one or more entity
and column mappings.

@SqlResultSetMapping(
  name="employeeResult",
  entities=@EntityResult(entityClass=Employee.class)
)

Here we have defined a SQL result set mapping called employeeResult that may be referenced by
any query returning Employee entity instances. The mapping consists of a single entity result, specified
by the @EntityResult annotation, which references the Employee entity class. THe query must supply 
values for all columns mapped by the entity, including foreign keys. It is vendor-specific whether the
entity is partially constructed or whether an error occurs if any required entity state is missing.


Mapping Foreign Keys(349)
Multiple Result Mappings:
a query may return more than one entity at a time;
This is most often useful if there is a one-to-one relationship between two entities;

For example:
SELECT emp_id, name, salary, manager_id, dept_id, address_id, id, street, city, state, zip
FROM emp, address
WHERE address_id = id

Mapping for this query:
@SqlResultSetMapping(
  name="EmployeeWithAddress",
  entities={@EntityResult(entityClass=Employee.class),
	    @EntityResult(entityClass=Address.class)}
)

Mapping Column Aliases
If the column aliases in the SQL statement do not directly match up with the names specified in the
column mappings for the entity, field result mappings are required for the query engine to make the
correct association.

Suppose, for example, that both the EMP and ADDRESS tables listed in the previous example 
used the column ID for their primary key. The query would have to be altered to alias the ID
columns so that they are unique:

SELECT emp.id AS emp_id, name, salary, manager_id, dept_id, address_id,
address.id, street, city, state, zip
FROM emp, address
WHERE address_id = address.id

The @FieldResult annotation is used to map column aliases to the entity attributes in situations
where the name in the query is not the same as the one used in the column mapping.
More than one
@FieldResult may be specified, but only the mappings that are different need to be specified.


@SqlResultSetMapping(
  name="EmployeeWithAddress",
  entities={@EntityResult(entityClass=Employee.class,
  fields=@FieldResult(
    name="id",
    column="EMP_ID")),
  @EntityResult(entityClass=Address.class)}
)

---------------------------------------------------------------------------------------------------------
Mapping Scalar Result Columns (350):

Mapping compound keys:
@EntityResult(
 entityClass=Employee.class,
 fields={
  @FieldResult(name="country", column="MGR_COUNTRY"),
  @FieldResult(name="id", column="MGR_ID"),
  @FieldResult(name="name", column="MGR_NAME"),
  @FieldResult(name="salary", column="MGR_SALARY"),
  @FieldResult(name="manager.country",
   column="MGR_MGR_COUNTRY"),
  @FieldResult(name="manager.id", column="MGR_MGR_ID")
}


Mappping Inheritance:

The key thing to remember is that if the results include
more than one entity type, each of the columns for all the possible entity types must be represented in
the query.

The only special
element in the @EntityResult annotation for use with inheritance is the discriminatorColumn element.
This element allows the name of the discriminator column to be specified in the unlikely event that it is
different from the mapped version.

To understand aliasing a discriminator column, consider the following query that returns data from
another EMPLOYEE_STAGE table structured to use single-table inheritance:
SELECT id, name, start_date, daily_rate, term, vacation, hourly_rate, salary, pension, type
FROM employee_stage

@SqlResultSetMapping(
	name="EmployeeStageMapping",
	entities=
		@EntityResult(
		 entityClass=Employee.class,
		 discriminatorColumn="TYPE",
		 fields={
		  @FieldResult(name="startDate", column="START_DATE"),
		  @FieldResult(name="dailyRate", column="DAILY_RATE"),
		  @FieldResult(name="hourlyRate", column="HOURLY_RATE")

---------------------------------------------------------------------------------------------------
Parameter Binding : JPA guarantees only the use of positional parameter binding for sql queries.

--------------------------------------------------------------------------------------------------


Lifecycle callbacks:In order to respond to any one or more of the events, an entity
class or any of its superclasses may declare one or more methods that will be invoked by the provider
when the event gets fired. These methods are called callback methods.


Lifecycle Events. Four categories: persisting, updating, removing, and loading.

These are really data-level events that correspond to the database operations of inserting,
updating, deleting, and reading; and except for loading, each has a Pre event and a Post event. In the
load category there is only a PostLoad event because it would not make any sense for there to be PreLoad
that was not yet built.

Thus the full suite of lifecycle events that can occur is composed of
PrePersist, PostPersist, PreUpdate, PostUpdate, PreRemove, PostRemove, and PostLoad.


"PrePersist and PostPersist"
The PrePersist event notifies an entity when EntityManager.persist() has been successfully invoked on
it. PrePersist events may also occur on a merge() call when a new entity has been merged into the
persistence context.

If multiple entities are cascaded to during the same operation, the order in which the PrePersist
callbacks occur cannot be relied upon.

PostPersist events occur when an entity is inserted, which normally occurs during the transaction
completion phase. Firing of a PostPersist event does not indicate that the entity has committed
successfully to the database because the transaction in which it was persisted may be rolled back after
the PostPersist event but before the transaction successfully commits.

"PreRemove and PostRemove"
When an EntityManager.remove() call is invoked on an entity, the PreRemove callback is triggered. This
callback implies that an entity is being queued for deletion, and any related entities across relationships
that have been configured with the REMOVE cascade option will also get a PreRemove notification. When
the SQL for deletion of an entity finally does get sent to the database, the PostRemove event will get fired.
As with the PostPersist lifecycle event, the PostRemove event does not guarantee success. The enclosing
transaction may still be rolled back.

"PreUpdate and PostUpdate"
Updates to managed entities may occur at any time, either within a transaction or (in the case of an
extended persistence context) outside a transaction. Because there is no explicit method on the
EntityManager, the PreUpdate callback is guaranteed to be invoked only at some point before the
database update. Some implementations may track changes dynamically and may invoke the callback
on each change, while others may wait until the end of the transaction and just invoke the callback once.

The PostUpdate callback occurs right after the
database update. The same potential for rollback exists after PostUpdate callbacks as with PostPersist
and PostRemove.

"PostLoad"
The PostLoad callback occurs after the data for an entity is read from the database and the entity
instance is constructed. This can get triggered by any operation that causes an entity to be loaded,
normally by either a query or traversal of a lazy relationship. It can also happen as a result of a refresh()
call on the entity manager. When a relationship is set to cascade REFRESH, the entities that get cascaded
to will also get loaded. The invocation of entities in a single operation, be it a query or a refresh, is not
guaranteed to be in any order

Tip: Other lifecycle methods may be defined by specific providers, such as when an entity is merged or
copied/cloned.


"Callback Methods" (355)
Callback methods may be defined a few different ways, the most basic of which is to simply define a
method on the entity class. Designating the method as a callback method involves two steps:
1. Define a method with according to a given signature and annotate is with the appropriate annotation.
The callback method may have any name, but must have a signature that takes no parameters and has a return type of void. 
Final or static methods are not valid callback methods.

Checked exceptions may not be thrown from callback methods because the method definition of a
callback method is not permitted to include a throws clause. Runtime exceptions may be thrown,
though, and if they are thrown while in a transaction, they will cause the provider to not only abandon
invocation of subsequent lifecycle event methods in that transaction, but also mark the transaction for
rollback.

A method is indicated as being a callback method by being annotated with a lifecycle event
annotation. The relevant annotations match the names of the events listed earlier: @PrePersist,
@PostPersist, @PreUpdate, @PostUpdate, @PreRemove, @PostRemove, and @PostLoad. A method may be
annotated with multiple lifecycle event annotations, but only one lifecycle annotation of a given type
may be present in an entity class.

366

Enterprise contexts (357)

Entity Listeners: 357
Callback methods in the entity are fine when you don’t mind if the event callback logic is included in the
entity, but what if you want to pull the event handling behavior out of the entity class into a different
class?

class? To do this, you can use an entity listener.

it is a class on which
you can define one or more lifecycle callback methods to be invoked for the lifecycle events of an entity.

only one method in each listener class may be
annotated for each event type. Multiple event listeners may be applied to an entity, though.

On an entity listener, a
callback method must have a similar signature as on an entity with the exception that it must also have a
single defined parameter of a type that is compatible with the entity type, as the entity class, a superclass
(including Object), or an interface implemented by the entity. A method with the signature public void
foo(Object o) {} is an example of a valid callback method on an entity listener. The method must then
be annotated with the necessary event annotation(s).

Entity listener classes must be stateless, meaning that they should not declare any fields. A single
instance may be shared among multiple entity instances and may even be invoked upon concurrently
for multiple entity instances. In order for the provider to be able to create instances of the entity listener,
every entity listener class must have a public no-argument constructor.

 Attaching Entity Listeners to Entities:

An entity designates the entity listeners that should be notified of its lifecycle events through the use of
the @EntityListeners annotation. One or more entity listeners may be listed in the annotation.

When a
lifecycle event occurs, the provider will iterate through each of the entity listeners in the order in which
they were listed and instantiate an instance of the entity listener class that has a method annotated with
the annotation for the given event. It will invoke the callback method on the listener, passing in the
entity to which the event applies. After it has done this for all the listed entity listeners, it will invoke the
callback method on the entity if there is one.

If any of the listeners throws an exception, it will abort the
callback process, causing the remaining listeners and the callback method on the entity to not be
invoked.

Entity
@EntityListeners({EmployeeDebugListener.class, NameValidator.class})
public class Employee{ .. }

public class EmployeeDebugListener {
@PrePersist
public void prePersist(Employee emp) {
System.out.println("Persist on employee id: " + emp.getId());
}

In general, when a
callback method accesses state beyond what should be publicly accessible, it is best suited to being in
the entity and not in an entity listener.


"Default Entity Listeners"
   A listener may be attached to more than one type of entity simply by being listed in the
@EntityListeners annotation of more than one entity. This can be useful in cases where the listener
provides a more general facility or wide-ranging runtime logic.

For even broader usage of an entity listener across all the entities in a persistence unit, one or more
default entity listeners may be declared. There is currently no standard annotation target for persistence
unit scoped metadata, so this kind of metadata can be declared only in an XML mapping file.

When a list of default entity listeners is declared, it will be traversed in the order they were listed in
the declaration, and each one that has a method annotated or declared for the current event will be
invoked upon.
Default entity listeners will always get invoked before any of the entity listeners listed in
the @EntityListeners annotation for a given entity.

Any entity may opt out of having the default entity listeners applied to it by using the
@ExcludeDefaultListeners annotation. When an entity is annotated with this annotation, none of the
declared default listeners will get invoked for the lifecycle events for instances of that entity type.

"Inheritance and lifecycle events"
Inheriting callback methods;
every callback method for a given event type will be invoked in the order
according to its place in the hierarchy, most general classes first.

Inheriting Entity listeners:
listeners listed in the entity superclass annotation get invoked before the listeners in the subclass
entities. In other words, defining an @EntityListeners annotation on an entity is additive in that it only
adds listeners; it does not redefine them or their order of invocation.

To redefine which entity listeners get invoked and their order of invocation, an entity or mapped
superclass should be annotated with @ExcludeSuperclassListeners. This will cause the listeners defined
in all the superclasses to not be invoked for any of the lifecycle events of the annotated entity subclass. If
we want a subset of the listeners to still be invoked, they must be listed in the @EntityListeners
annotation on the overriding entity and in the order that is appropriate.

"Lifecycle event invocation order" (360)
If a given lifecycle event X occurs for entity A, the provider will do the
following:
1. Check whether any default entity listeners exist (see Chapter 12). If they do,
iterate through them in the order they are defined and look for methods that
are annotated with the lifecycle event X annotation. Invoke the lifecycle method
on the listener if a method was found.
2. Check on the highest mapped superclass or entity in the hierarchy for classes
that have an @EntityListeners annotation. Iterate through the entity listener
classes that are listed in the annotation and look for methods that are
annotated with the lifecycle event X annotation. Invoke the lifecycle method on
the listener if a method was found.
3. Repeat step 2 going down the hierarchy on entities and mapped superclasses
until entity A is reached, and then repeat it for entity A.
4. Check on the highest mapped superclass or entity in the hierarchy for methods
that are annotated with the lifecycle event X annotation. Invoke the callback
method on the entity if a method was found and the method is not also defined
in entity A with the lifecycle event X annotation on it.
5. Repeat step 2 going down the hierarchy on entities and mapped superclasses
until entity A is reached.
6. Invoke any methods that are defined on A and annotated with the lifecycle
event X annotation.

-----------------------------------------------------------------------------------------------------------
"Validation" (363)
 In Java EE 6, validation is
considered a separate aspect of the application; a mechanism was developed and standardized (in JSR
303) for the platform. It was also designed to function in a stand-alone Java SE environment.

Using constraints:

public class Employee {
 @NotNull
 private int id;
 @NotNull(message="Employee name must be specified")
 @Size(max=40)
 private String name;
 @Past
 private Date startDate;
 // ...
}

All validation constraints are defined in javax.validation.constraints package.

@Null Element must be null
@NotNull Element must not be null
@AssertTrue Element must be true
@AssertFalse Element must be false
@Min long value() Element must have a value greater than or
equal to the minimum
@Max long value() Element must have a value less than or equal to
the maximum
@DecimalMin String value() Element must have a value greater than or
equal to the minimum
@DecimalMax String value() Element must have a value less than or equal to
the maximum
@Size int min() Element must have a value between the
specified limits
int max()
@Digits int integer() Element must be a number within the specified
range
int fraction()
@Past Element must be a date in the past
@Future Element must be a date in the future
@Pattern String regexpr() Element must match the specified regular
expression
Flag[] flags (Flags offer regular expression settings)


Invoking Validation (365):
The main API class for invoking validation on an object is javax.validation.Validator class

Once Validator is obtained, you can call validate() method on it.

Validation is designed similarly to JPA in many respects. It is divided into a set of APIs and a
validation implementation, or validation provider, and the way that providers advertise themselves is by
using the same service provider model. Providers contain META-INF/services files that indicate their SPI
classes to be invoked.
Like JPA, validation is used slightly differently depending upon whether it is used in container mode
or in Java SE mode. In a container, a Validator instance may be injected into any Java EE component
that supports injection. The example definition of a stateless session bean in Listing 11-18 shows that the
regular Java EE @Resource injection annotation can be used.

@Stateless
 public class EmployeeOperationsEJB implements EmployeeOperations {
 @Resource
 Validator validator;
 public void newEmployee(Employee emp) {
 validator.validate(emp);
 //…
}
//…
}


For non-container environment:
ValidatorFactory factory = Validation.buildDefaultValidatorFactory();

Validator validator = factory.getValidator();

When the validate method fails and a constraint is not satisfied, a ValidationException is thrown
with an accompanying message String that is dictated by the definition of the constraint that was not
met.

Validation groups.
It may be that the same object needs to be validated at different times for multiple different constraint
sets. To achieve this, we would create separate validation groups and specify which group or groups the
constraint belongs to.

When a group is passed as an argument during validation, all constraints that are
a part of that group are checked for validity. When no group is specified on a constraint or as an
argument to the validate() method, the Default group is assumed.
Groups are defined and referenced as classes.

public interface FullTime extends Default {}
public interface PartTime extends Default {}

public class Employee {
@NotNull
private int id;
@NotNull
@Size(max=40)
private String name;
@NotNull(groups=FullTime.class)
@Null(groups=PartTime.class)
private long salary;
@NotNull(groups=PartTime.class)
@Null(groups=FullTime.class)
private double hourlyWage;
// ...
}

"Creating new Constraints" (368)

One of the most valuable aspects of validation is the ability to add new constraints for a given
application, or even to share across applications. Constraints may be implemented to be applicationspecific
and tied to a particular business logic, or they may be generalized and bundled up in constraint
libraries for reuse.

Implementing a custom constraint annotation:

/**
* Indicate that a number should be even.
* May be applied on fields or properties of type Integer.
*/
@Constraint(validatedBy={EvenNumberValidator.class})
@Target({METHOD, FIELD})
@Retention(RUNTIME)
public @interface Even {
 String message() default "Number must be even";
 Class<?>[] groups() default {};
 Class<? extends ConstraintPayload>[] payload() default {};
 boolean includeZero() default true;
}

For each constraint annotation there must be one or more constraint implementation classes. Each class
must implement the javax.validation.ConstraintValidator interface and provide the logic to validate
the value being checked:

public class EvenNumberValidator
implements ConstraintValidator<Even,Integer> {
boolean includesZero;
public void initialize(Even constraint) {
includesZero = constraint.includeZero();
}
public boolean isValid(Integer value,
ConstraintValidatorContext ctx) {
if (value == null)
return true;
if (value == 0)
return includesZero;
return value % 2 == 0;
}
}


Validation in JPA (370):

When validating JPA entities there is a specific integration required with the JPA provider. There are a few
reasons for this integration.
First and foremost, an entity may have lazily loaded attributes, and because a validator does not
have a dependency on, or knowledge of, JPA, it would not know when an attribute has not been loaded.
The process of validation could unwittingly cause the entire object graph to be loaded into memory!
Another case is if validation is occurring on a JPA entity on the client side and the unloaded attributes
are not even loadable. In this case, validation would produce an exception, not quite as bad as loading
the entire object graph, but still clearly undesirable.

The most practical reason for a JPA integration is that most often we want validation to be invoked
automatically at specific lifecycle phases.

It turns out that the most
convenient lifecycle events to trigger validation at are PrePersist, PreUpdate, and PreRemove, so if
validation is enabled these events will cause the validator to do its work.

@Entity
public class Employee {
  @Id @NotNull
  private int id;
  @NotNull
  @Size(max=40)
  private String name;
  @Past
  private Date startDate;
  @Embedded
  @Valid
  private EmployeeInfo info;
  @ManyToOne
  private Address address;
  // ...
}

When an entity is validated, each of the fields or properties, or even the type itself, is validated
according to the regular validation rules. However, the validation specification dictates that when a
@Valid annotation is present on a field or property, the validation process proceeds to the object stored
in that field or property. Embeddables may optionally be annotated with @Valid in order to be traversed
during validation, but relationships may not: related entities, such as
the Address, will also not be validated unless they themselves have been persisted, updated, or removed.

Enabling Validation
When no overriding settings are present at the JPA configuration level, validation is on by default when a
validation provider is on the classpath. To explicitly control whether validation should be enabled or
disabled there are two possible settings:

"validation-mode" element in the persistence.xml file. This element may be set to
one of three possible values:
1. "AUTO" —Turn on validation when a validation provider is present on the
classpath (default)
2. "CALLBACK" —Turn on validation and throw an error if no validation provider is
available
3. "NONE" —Turn off validation

javax.persistence.validation.mode persistence property. This property may be
specified in the Map passed to the createEntityManagerFactory() method and
overrides the validation-mode setting if present. Possible values are the string
equivalents of the validation-mode values, "auto", "callback", and "none", and
have exactly the same meanings as their validation-mode counterparts.



"Setting Lifecycle Validation Groups"
By default, each of the PrePersist and PreUpdate lifecycle events will trigger validation on the affected
entity, immediately following the event callback, using the Default validation group.

To change the groups being validated at the three
different lifecycle event types, any of the following properties may be specified, either as properties in
the properties section of the persistence.xml file, or in the Map passed into
createEntityManagerFactory():

javax.persistence.validation.group.pre-persist—Set the groups to validate
at PrePersist time
javax.persistence.validation.group.pre-update—Set the groups to validate at
PreUpdate time
javax.persistence.validation.group.pre-remove—Set the groups to validate at
PreRemove time

By setting these properties to a particular group or groups, you can isolate the kinds of validation
that get performed on entities across different lifecycle events. For example, you may create groups
called Create, Update, and Remove, and then when you want some kind of validation to occur on one or
more of these events you need only set the groups on the relevant constraints to be checked.

------------------------------------------------------------------------------------------------------------------------------
"Concurrency" (372):
Entity Operations
A managed entity belongs to a single persistence context and should not be managed by more than one
persistence context at any given time. This is an application responsibility, however, and may not
necessarily be enforced by the persistence provider. Merging the same entity into two different open
persistence contexts could produce undefined results.

Entity managers and the persistence contexts that they manage are not intended to be accessed by
more than one concurrently executing thread. The application cannot expect it to be synchronized and
is responsible for ensuring that it stays within the thread that obtained it.

Entity Access
Applications may not access an entity directly from multiple threads while it is managed by a persistence
context. An application may choose, however, to allow entities to be accessed concurrently when they
are detached. If it chooses to do so, the synchronization must be controlled through the methods coded
on the entity. Concurrent entity state access is not recommended, however, because the entity model
does not lend itself well to concurrent patterns.

It would be preferable to simply copy the entity and pass
the copied entity to other threads for access and then merge any changes back into a persistence context
when they need to be persisted.

Refreshing Entity State:
The refresh() method of the EntityManager interface can be useful in situations when we know or
suspect that there are changes in the database that we do not have in our managed entity. The refresh
operation applies only when an entity is managed because when we are detached we typically only need
to issue a query to get an updated version of the entity from the database.
























